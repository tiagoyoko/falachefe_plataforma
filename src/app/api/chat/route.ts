import { NextRequest, NextResponse } from 'next/server'
import { falachefeSecretaryAgent } from '@/agents/falachefe-secretary-agent'

/**
 * Extract name from message
 */
function extractName(message: string): string {
  const lowerMessage = message.toLowerCase()
  
  // Try to find name patterns
  const patterns = [
    /meu nome √© (\w+)/i,
    /me chamo (\w+)/i,
    /sou o (\w+)/i,
    /sou a (\w+)/i,
    /my name is (\w+)/i,
    /i am (\w+)/i,
    /nome √© (\w+)/i,
    /chamo (\w+)/i
  ]
  
  for (const pattern of patterns) {
    const match = message.match(pattern)
    if (match && match[1]) {
      return match[1].charAt(0).toUpperCase() + match[1].slice(1)
    }
  }
  
  // Fallback: try to find capitalized words
  const words = message.split(' ')
  for (const word of words) {
    if (word.length > 2 && /^[A-Z]/.test(word) && /^[a-zA-Z]+$/.test(word)) {
      return word
    }
  }
  
  return 'Usu√°rio'
}

/**
 * Process message using OpenAI Agents SDK with Memory System
 */
async function processMessage(message: string, userId?: string, conversationId?: string): Promise<any> {
  console.log('üöÄ Processing message with OpenAI Agents SDK and Memory System')
  
  try {
    const result = await falachefeSecretaryAgent.processMessage(message, userId, conversationId)
    console.log('‚úÖ OpenAI Agents SDK with Memory Response generated successfully')
    return result
  } catch (error) {
    console.error('‚ùå OpenAI Agents SDK Error:', error)
    
    // Simple fallback response
    return {
      response: `ü§ñ **Secret√°ria Virtual do Falachefe**\n\nEstou enfrentando algumas dificuldades t√©cnicas, mas estou aqui para ajud√°-lo com o Falachefe.\n\n**Principais √°reas:**\nüí∞ Gest√£o Financeira\nüìã Organiza√ß√£o de Neg√≥cios\nüè¢ Suporte e Informa√ß√µes\n\nPode reformular sua pergunta?`,
      agentId: 'falachefe-secretary-error',
      confidence: 0.3,
      processingTime: 100,
      metadata: {
        type: 'error',
        capabilities: ['financial', 'organization', 'support'],
        error: true,
        reason: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  }
}

export async function POST(request: NextRequest) {
  try {
    const { message, userId, conversationId } = await request.json()
    
    if (!message || typeof message !== 'string') {
      return NextResponse.json(
        { error: 'Message is required and must be a string' },
        { status: 400 }
      )
    }

    console.log(`üì® Processing message: "${message}"`, { userId, conversationId })
    
    // Process message with OpenAI Agents SDK and Memory System
    const response = await processMessage(message, userId, conversationId)
    
    console.log(`‚úÖ Response generated by ${response.agentId} (confidence: ${response.confidence})`)
    
    return NextResponse.json({
      content: response.response,
      type: response.metadata.type || 'general',
      confidence: response.confidence,
      processingTime: response.processingTime,
      agentId: response.agentId,
      metadata: response.metadata
    })
    
  } catch (error) {
    console.error('‚ùå Error processing message:', error)
    
    return NextResponse.json({
      content: `üö® **System Error**\n\nI'm experiencing technical difficulties. Please try again in a moment.\n\n*Error: ${error instanceof Error ? error.message : 'Unknown error'}*`,
      type: 'general',
      confidence: 0.1,
      processingTime: 0,
      agentId: 'error',
      metadata: {
        error: true,
        reason: 'Critical system error'
      }
    }, { status: 500 })
  }
}

/**
 * Health check endpoint
 */
export async function GET() {
  try {
    return NextResponse.json({
      status: 'healthy',
      system: 'falachefe-secretary',
      agent: 'Falachefe Secretary Agent',
      timestamp: new Date().toISOString(),
      capabilities: ['financial', 'organization', 'support', 'information'],
      features: [
        'Gest√£o Financeira',
        'Organiza√ß√£o de Neg√≥cios', 
        'Suporte T√©cnico',
        'Informa√ß√µes da Empresa'
      ]
    })
  } catch (error) {
    return NextResponse.json({
      status: 'error',
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    }, { status: 500 })
  }
}